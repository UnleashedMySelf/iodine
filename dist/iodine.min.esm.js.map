{"version":3,"file":"iodine.min.esm.js","sources":["../src/iodine.js"],"sourcesContent":["/*\n|--------------------------------------------------------------------------\n| Iodine - JavaScript Library\n|--------------------------------------------------------------------------\n|\n| This library contains a collection of useful validation rules that can\n| be used to quickly verify whether items meet certain conditions.\n|\n*/\nexport default class Iodine\n{\n    /**\n     * Constructor.\n     *\n     */\n    constructor()\n    {\n        this.locale = undefined;\n\n        this.messages = {\n            after         : \"The date must be after: '[PARAM]'\",\n            afterOrEqual  : \"The date must be after or equal to: '[PARAM]'\",\n            array         : \"[FIELD] must be an array\",\n            before        : \"The date must be before: '[PARAM]'\",\n            beforeOrEqual : \"The date must be before or equal to: '[PARAM]'\",\n            boolean       : \"[FIELD] must be true or false\",\n            date          : \"[FIELD] must be a date\",\n            different     : \"[FIELD] must be different to '[PARAM]'\",\n            endsWith      : \"[FIELD] must end with '[PARAM]'\",\n            email         : \"[FIELD] must be a valid email address\",\n            falsy         : \"[FIELD] must be a falsy value (false, 'false', 0 or '0')\",\n            in            : \"[FIELD] must be one of the following options: [PARAM]\",\n            integer       : \"[FIELD] must be an integer\",\n            json          : \"[FIELD] must be a parsable JSON object string\",\n            max           : \"[FIELD] must be less than or equal to [PARAM]\",\n            min           : \"[FIELD] must be greater than or equal to [PARAM]\",\n            maxLength     : \"[FIELD] must not be greater than '[PARAM]' in character length\",\n            minLength     : \"[FIELD] must not be less than '[PARAM]' character length\",\n            notIn         : \"[FIELD] must not be one of the following options: [PARAM]\",\n            numeric       : \"[FIELD] must be numeric\",\n            optional      : \"[FIELD] is optional\",\n            regexMatch    : \"[FIELD] must satisify the regular expression: [PARAM]\",\n            required      : \"[FIELD] must be present\",\n            same          : \"[FIELD] must be '[PARAM]'\",\n            startsWith    : \"[FIELD] must start with '[PARAM]'\",\n            string        : \"[FIELD] must be a string\",\n            truthy        : \"[FIELD] must be a truthy value (true, 'true', 1 or '1')\",\n            url           : \"[FIELD] must be a valid url\",\n            uuid          : \"[FIELD] must be a valid UUID\",\n        };\n    }\n\n    /**\n     * @internal.\n     *\n     */\n    _compare(first, second, type, equals = false)\n    {\n        if (! this.assertDate(first)) return false;\n\n        if (! this.assertDate(second) && ! this.assertInteger(second)) return false;\n\n        second = typeof second === 'number' ? second : second.getTime();\n\n        if (type === 'less' && equals)   return first.getTime() <= second;\n        if (type === 'less' && ! equals) return first.getTime() < second;\n        if (type === 'more' && equals)   return first.getTime() >= second;\n        if (type === 'more' && ! equals) return first.getTime() > second;\n    }\n\n    /**\n     * @internal.\n     *\n     */\n    _error(rule, args = undefined)\n    {\n        let { param, field } = typeof args === 'object' ? args : { param : args, field : undefined };\n\n        const chunks = rule.split(':');\n\n        let key = chunks.shift();\n\n        param = param || chunks.join(':');\n\n        if (['after', 'afterOrEqual', 'before', 'beforeOrEqual'].includes(key)) {\n            param = new Date(parseInt(param)).toLocaleTimeString(this.locale, {\n                year   : 'numeric',\n                month  : 'short',\n                day    : 'numeric',\n                hour   : '2-digit',\n                minute : 'numeric',\n                hour12 : false,\n            });\n        }\n\n        let message = [null, undefined, ''].includes(param)\n            ? this.messages[key]\n            : this.messages[key].replace('[PARAM]', param);\n\n        return [null, undefined, ''].includes(field)\n            ? message.replace('[FIELD]', this.default_field_name ?? 'Value')\n            : message.replace('[FIELD]', field);\n    }\n\n    /**\n     * @internal.\n     *\n     */\n    _missing()\n    {\n        return {\n            valid : false,\n            rule  : 'None',\n            error : 'Rules exist, but no value was provided to check',\n        };\n    }\n\n    /**\n     * @internal.\n     *\n     */\n    _prepare(value, rules = [])\n    {\n        if (! rules.length) return [];\n\n        if (rules[0] === 'optional' && this.assertOptional(value)) return [];\n\n        return rules.filter(rule => rule !== 'optional').map(rule =>\n            typeof(rule) === 'string'\n            ? [rule, this._title(rule.split(':').shift()), rule.split(':').slice(1).join(':')]\n            : [`${ rule.rule }:${ rule.param }`, this._title(rule.rule), rule.param]\n        );\n    }\n\n    /**\n     * @internal.\n     *\n     */\n    _title(value)\n    {\n        return `${value[0].toUpperCase()}${value.slice(1)}`;\n    }\n\n    /**\n     * @internal.\n     *\n     */\n    _validate(value, rules)\n    {\n        for (let index in rules = this._prepare(value, rules)) {\n            if (! this[`assert${rules[index][1]}`].apply(this, [value, rules[index][2]])) {\n                return {\n                    valid : false,\n                    rule  : rules[index][0],\n                    error : this._error(rules[index][0]),\n                };\n            }\n        }\n\n        return {\n            valid : true,\n            rule  : '',\n            error : '',\n        };\n    }\n\n    /**\n     * Determine if the given content matches the given schema.\n     *\n     */\n    assert(values, schema)\n    {\n        if (Array.isArray(schema)) {\n            return this._validate(values, schema);\n        }\n\n        let keys = Object.keys(schema);\n\n        let result = { valid : true, fields : { } };\n\n        for (let i = 0; i < keys.length; i++) {\n            result.fields[keys[i]] = values.hasOwnProperty(keys[i])\n                ? this._validate(values[keys[i]], schema[keys[i]])\n                : this._missing();\n\n            if (! result.fields[keys[i]].valid) {\n                result.valid = false;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Determine if the given date is after another given date.\n     *\n     */\n    assertAfter(value, after)\n    {\n        return this._compare(value, after, 'more', false);\n    }\n\n    /**\n     * Determine if the given date is after or equal to another given date.\n     *\n     */\n    assertAfterOrEqual(value, after)\n    {\n        return this._compare(value, after, 'more', true);\n    }\n\n    /**\n     * Determine if the given value is an array.\n     *\n     */\n    assertArray(value)\n    {\n        return Array.isArray(value);\n    }\n\n    /**\n     * Determine if the given date is before another given date.\n     *\n     */\n    assertBefore(value, before)\n    {\n        return this._compare(value, before, 'less', false);\n    }\n\n    /**\n     * Determine if the given date is before or equal to another given date.\n     *\n     */\n    assertBeforeOrEqual(value, before)\n    {\n        return this._compare(value, before, 'less', true);\n    }\n\n    /**\n     * Determine if the given value is a boolean.\n     *\n     */\n    assertBoolean(value)\n    {\n        return [true, false].includes(value);\n    }\n\n    /**\n     * Determine if the given value is a date object.\n     *\n     */\n    assertDate(value)\n    {\n        return (value && Object.prototype.toString.call(value) === '[object Date]' && ! isNaN(value));\n    }\n\n    /**\n     * Determine if the given value is different to another given value.\n     *\n     */\n    assertDifferent(value, different)\n    {\n        return value != different;\n    }\n\n    /**\n     * Determine if the given value ends with another given value.\n     *\n     */\n    assertEndsWith(value, sub)\n    {\n        return this.assertString(value) && value.endsWith(sub);\n    }\n\n    /**\n     * Determine if the given value is a valid email address.\n     *\n     */\n    assertEmail(value)\n    {\n        let regex = \"^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$\";\n\n        return new RegExp(regex).test(String(value).toLowerCase());\n    }\n\n    /**\n     * Determine if the given value is falsy.\n     *\n     */\n    assertFalsy(value)\n    {\n        return [0, '0', false, 'false'].includes(value);\n    }\n\n    /**\n     * Determine if the given value is within the given array of options.\n     *\n     */\n    assertIn(value, options)\n    {\n        return (typeof options === 'string' ? options.split(',') : options).includes(value);\n    }\n\n    /**\n     * Determine if the given value is an integer.\n     *\n     */\n    assertInteger(value)\n    {\n        return Number.isInteger(value) && parseInt(value).toString() === value.toString();\n    }\n\n    /**\n     * Determine if the given value is a JSON string.\n     *\n     */\n    assertJson(value)\n    {\n        try {\n            return typeof JSON.parse(value) === 'object';\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * Determine if the given number is less than or equal to the maximum limit.\n     *\n     */\n    assertMax(value, limit)\n    {\n        return parseFloat(value) <= limit;\n    }\n\n    /**\n     * Determine if the given number is greater than or equal to the minimum limit.\n     *\n     */\n    assertMin(value, limit)\n    {\n        return parseFloat(value) >= limit;\n    }\n\n    /**\n     * Determine if the given value string length is less than or equal to the maximum limit.\n     *\n     */\n    assertMaxLength(value, limit)\n    {\n        return typeof value === 'string' ? value.length <= limit : false;\n    }\n\n    /**\n     * Determine if the given value string length is greater than or equal to the minimum limit.\n     *\n     */\n    assertMinLength(value, limit)\n    {\n        return typeof value === 'string' ? value.length >= limit : false;\n    }\n\n    /**\n     * Determine if the given value is not within the given array of options.\n     *\n     */\n    assertNotIn(value, options)\n    {\n        return ! this.assertIn(value, options);\n    }\n\n    /**\n     * Determine if the given value is numeric (an integer or a float).\n     *\n     */\n    assertNumeric(value)\n    {\n        return ! isNaN(parseFloat(value)) && isFinite(value);\n    }\n\n    /**\n     * Determine if the given value is optional.\n     *\n     */\n    assertOptional(value)\n    {\n        return [null, undefined, ''].includes(value);\n    }\n\n    /**\n     * Determine if the given value satisifies the given regular expression.\n     *\n     */\n    assertRegexMatch(value, expression)\n    {\n        return new RegExp(expression).test(String(value));\n    }\n\n    /**\n     * Determine if the given value is present.\n     *\n     */\n    assertRequired(value)\n    {\n        return ! this.assertOptional(value);\n    }\n\n    /**\n     * Determine if the given value is the same as another given value.\n     *\n     */\n    assertSame(value, same)\n    {\n        return value == same;\n    }\n\n    /**\n     * Determine if the given value starts with another given value.\n     *\n     */\n    assertStartsWith(value, sub)\n    {\n        return this.assertString(value) && value.startsWith(sub);\n    }\n\n    /**\n     * Determine if the given value is a string.\n     *\n     */\n    assertString(value)\n    {\n        return typeof value === 'string';\n    }\n\n    /**\n     * Determine if the given value is truthy.\n     *\n     */\n    assertTruthy(value)\n    {\n        return [1, '1', true, 'true'].includes(value);\n    }\n\n    /**\n     * Determine if the given value is a valid URL.\n     *\n     */\n    assertUrl(value)\n    {\n        let regex = \"^(https?:\\\\/\\\\/)?((([a-z\\\\d]([a-z\\\\d-]*[a-z\\\\d])*)\\\\.)+[a-z]{2,}|((\\\\d{1,3}\\\\.){3}\\\\d{1,3}))(\\\\:\\\\d+)?(\\\\/[-a-z\\\\d%_.~+]*)*(\\\\?[;&a-z\\\\d%_.~+=-]*)?(\\\\#[-a-z\\\\d_]*)?$\";\n\n        return new RegExp(regex).test(String(value).toLowerCase());\n    }\n\n    /**\n     * Determine if the given value is a valid UUID.\n     *\n     */\n    assertUuid(value)\n    {\n        let regex = \"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\";\n\n        return new RegExp(regex).test(String(value).toLowerCase());\n    }\n\n    /**\n     * Attach a custom validation rule to the library.\n     *\n     */\n    rule(name, closure)\n    {\n        Iodine.prototype[`assert${this._title(name)}`] = closure;\n    }\n\n    /**\n     * Replace the default error messages with a new set.\n     *\n     */\n    setErrorMessages(messages)\n    {\n        this.messages = messages;\n    }\n\n    /**\n     * Add or replace an error message.\n     *\n     */\n    setErrorMessage(key, message)\n    {\n        this.messages[key] = message;\n    }\n\n    /**\n     * Replace the default locale with a new value.\n     *\n     */\n    setLocale(locale)\n    {\n        this.locale = locale;\n    }\n\n    /**\n     * Replace the default field name with a new value.\n     *\n     */\n    setDefaultFieldName(fieldName)\n    {\n        this.default_field_name = fieldName;\n    }\n}\n\n/**\n * Create an instance of the library.\n *\n */\nif (typeof window !== 'undefined') {\n    window.Iodine = new Iodine();\n}\n"],"names":["Iodine","constructor","this","locale","undefined","messages","after","afterOrEqual","array","before","beforeOrEqual","boolean","date","different","endsWith","email","falsy","in","integer","json","max","min","maxLength","minLength","notIn","numeric","optional","regexMatch","required","same","startsWith","string","truthy","url","uuid","_compare","first","second","type","equals","assertDate","assertInteger","getTime","_error","rule","args","param","field","chunks","split","shift","join","includes","key","parseInt","toLocaleTimeString","year","month","day","hour","minute","hour12","replace","message","default_field_name","_missing","valid","error","_prepare","value","rules","length","assertOptional","filter","map","_title","slice","toUpperCase","_validate","index","apply","assert","values","schema","Array","isArray","Object","keys","result","fields","i","hasOwnProperty","assertAfter","assertAfterOrEqual","assertArray","assertBefore","assertBeforeOrEqual","assertBoolean","prototype","toString","call","isNaN","assertDifferent","assertEndsWith","sub","assertString","assertEmail","test","String","toLowerCase","assertFalsy","assertIn","options","isInteger","assertJson","JSON","parse","e","assertMax","limit","parseFloat","assertMin","assertMaxLength","assertMinLength","assertNotIn","assertNumeric","isFinite","assertRegexMatch","expression","assertRequired","assertSame","assertStartsWith","assertTruthy","assertUrl","RegExp","assertUuid","name","closure","setErrorMessages","setErrorMessage","setLocale","setDefaultFieldName","fieldName","window"],"mappings":"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"}